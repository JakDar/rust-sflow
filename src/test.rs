use flow_records::FlowRecord;
use header_record::layer4::l4::Layer4Packet;
use header_record::layer7::http::HttpRequest;
use header_record::layer7::http::HttpResponse;
use header_record::layer7::l7::Layer7Packet;
// External Test Imports
#[cfg(test)]
use rustc_serialize::hex::FromHex;
use std::io::Read;
// Standard Imports
use std::io::Cursor;
use utils::Decodeable;

// const RAW_TEST_DATA: &'static str = "this data is redacted";
//
// #[test]
// fn test_decode_datagram() {
//
// let hex_data = RAW_TEST_DATA.clone().from_hex().unwrap();
// let mut data = Cursor::new(hex_data);
//
// let d: Datagram = ::utils::Decodeable::read_and_decode(&mut data).unwrap();
// TODO: Add more tests here.
// assert_eq!(d.sample_record.len(), 6);
#[test]
fn http_get_response() {
    let mut stream = Cursor::new(vec![
        0x00u8, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x90,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x03, 0xa1,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x80,
        0xfa, 0x95, 0x17, 0xe2, 0x91, 0x42, 0x3e, 0x9e,
        0x1b, 0x06, 0x99, 0xcd, 0x08, 0x00, 0x45, 0x00,
        0x03, 0x8f, 0xee, 0x5c, 0x40, 0x00, 0x40, 0x06,
        0xbd, 0xb8, 0xc0, 0xa8, 0x05, 0x02, 0xc0, 0xa8,
        0x05, 0x01, 0x00, 0x50, 0xdf, 0xc0, 0x9c, 0xce,
        0x2f, 0x35, 0xf0, 0x6a, 0x66, 0xda, 0x80, 0x18,
        0x00, 0xe3, 0xb2, 0xb9, 0x00, 0x00, 0x01, 0x01,
        0x08, 0x0a, 0xfc, 0x88, 0x4a, 0x6b, 0x43, 0x7f,
        0x20, 0x44, 0x48, 0x54, 0x54, 0x50, 0x2f, 0x31,
        0x2e, 0x31, 0x20, 0x32, 0x30, 0x30, 0x20, 0x4f,
        0x4b, 0x0d, 0x0a, 0x53, 0x65, 0x72, 0x76, 0x65,
        0x72, 0x3a, 0x20, 0x6e, 0x67, 0x69, 0x6e, 0x78,
        0x2f, 0x31, 0x2e, 0x31, 0x30, 0x2e, 0x33, 0x20,
        0x28, 0x55, 0x62, 0x75, 0x6e, 0x74, 0x75, 0x29,
        0x0d, 0x0a, 0x44, 0x61, 0x74, 0x65, 0x3a, 0x20,
        0x53, 0x75, 0x6e, 0x2c, 0x20, 0x32, 0x36, 0x20]);


    let flow = FlowRecord::read_and_decode(&mut stream).unwrap();


    let res = match flow {
        FlowRecord::SampledHeader(sample) => sample,
        _ => panic!()
    };

    assert_eq!(stream.read_to_end(&mut vec![]).unwrap(), 0);
    assert_eq!(res.frame_length, 929);
    assert_eq!(res.stripped, 4);
    assert_eq!(res.packet.packet.ttl, 64u8);
    assert_eq!(res.packet.packet.total_length, 911u16);

    let tcp = match res.packet.packet.content.clone() {
        Layer4Packet::TCP(tcp) => tcp,
        _ => panic!()
    };

    assert_eq!(tcp.dst_port, 57280);
}

#[test]
fn icmp() {
    let mut stream = Cursor::new(vec![
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x74,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x66,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x62,
        0x3e, 0x9e, 0x1b, 0x06, 0x99, 0xcd, 0xfa, 0x95,
        0x17, 0xe2, 0x91, 0x42, 0x08, 0x00, 0x45, 0x00,
        0x00, 0x54, 0xc3, 0xb6, 0x40, 0x00, 0x40, 0x01,
        0xeb, 0x9e, 0xc0, 0xa8, 0x05, 0x01, 0xc0, 0xa8,
        0x05, 0x02, 0x08, 0x00, 0x7a, 0x29, 0x60, 0x8d,
        0x00, 0x09, 0xb5, 0xb8, 0x82, 0x5b, 0x00, 0x00,
        0x00, 0x00, 0x21, 0x59, 0x05, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d,
        0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25,
        0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d,
        0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
        0x36, 0x37, 0x00, 0x00
    ]);


    let flow = FlowRecord::read_and_decode(&mut stream).unwrap();


    let res = match flow {
        FlowRecord::SampledHeader(sample) => sample,
        _ => panic!()
    };

    assert_eq!(stream.read_to_end(&mut vec![]).unwrap(), 0);
    assert_eq!(res.packet.packet.total_length, 84u16);

    let icmp = match res.packet.packet.content.clone() {
        Layer4Packet::Icmp(icmp) => icmp,
        _ => panic!()
    };

    assert_eq!(icmp.header_checksum, 0x7a29);
}


#[test]
fn icmp2() {
    let mut stream = Cursor::new(vec![
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x74,
        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x66,
        0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x62,
        0x3e, 0x9e, 0x1b, 0x06, 0x99, 0xcd, 0xfa, 0x95,
        0x17, 0xe2, 0x91, 0x42, 0x08, 0x00, 0x45, 0x00,
        0x00, 0x54, 0xc3, 0xb6, 0x40, 0x00, 0x40, 0x01,
        0xeb, 0x9e, 0xc0, 0xa8, 0x05, 0x01, 0xc0, 0xa8,
        0x05, 0x02, 0x08, 0x00, 0x7a, 0x29, 0x60, 0x8d,
        0x00, 0x09, 0xb5, 0xb8, 0x82, 0x5b, 0x00, 0x00,
        0x00, 0x00, 0x21, 0x59, 0x05, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15,
        0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d,
        0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25,
        0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d,
        0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
        0x36, 0x37, 0x00, 0x00
    ]);


    let flow = FlowRecord::read_and_decode(&mut stream).unwrap();


    let res = match flow {
        FlowRecord::SampledHeader(sample) => sample,
        _ => panic!()
    };

    assert_eq!(stream.read_to_end(&mut vec![]).unwrap(), 0);
    assert_eq!(res.packet.packet.total_length, 84u16);

    let icmp = match res.packet.packet.content.clone() {
        Layer4Packet::Icmp(icmp) => icmp,
        _ => panic!()
    };

    assert_eq!(icmp.header_checksum, 0x7a29);
}

#[test]
fn test_decode_string() {
    struct TestDecodeStringCase {
        raw_test_data: &'static str,
        result: &'static str,
    };

    let test_cases: Vec<TestDecodeStringCase> = vec![
            TestDecodeStringCase { raw_test_data: "00000006666f6f626172", result: "foobar" },
    ];

    for case in test_cases {
        let mut data = Cursor::new(case.raw_test_data.clone().from_hex().unwrap());
        let res: String = ::utils::Decodeable::read_and_decode(&mut data).unwrap();

        assert_eq!(case.result, res);
    }
}


#[test]
fn http_request() {
    let http_request = "POST /test/demo_form.php HTTP/1.1
    Host: w3schools.com
    name1=value1&name2=value2";


    let decoded = Layer7Packet::decode(http_request);
    assert_eq!(decoded, Layer7Packet::HttpReq(HttpRequest { host: Option::Some("w3schools.com".to_string()), path: "/test/demo_form.php".to_string(), method: "POST".to_string() }))
}

#[test]
fn http_resp() {
    let http_request = "HTTP/1.1 200 OK
Date: Tue, 25 Sep 2018 17:11:20 GMT
Server: Apache
Content-Transfer-Encoding: Binary
Cache-Control: max-age=68502, public, no-transform, must-revalidate
Last-Modified: Tue, 25 Sep 2018 01:13:08 GMT
Content-Length: 1776 ";


    let decoded = Layer7Packet::decode(http_request);

    assert_eq!(decoded, Layer7Packet::HttpResp(HttpResponse { status_code: 200 }))
}
